<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>关于JVM，你必须知道的那些玩意儿 | ClericYi's Blog</title><meta name="description" content="类的加载机制先使用一张图整个加载机制所包含的过程。  通过这张图我们可以了解到，关于类的加载其实就是可以分为五个大阶段，不过下面文中主要从加载、验证、准备、解析还有初始化这五个方面来做一个讲解： 加载需要完成以下三项任务：  （1）通过一个类的全限定名来获取定义此类的二进制字节流。（并没有指定数据必须从Class文件中获取） （2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。"><meta name="author" content="Cleric Yi"><meta name="copyright" content="Cleric Yi"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://yoursite.com/2020/06/24/%E5%85%B3%E4%BA%8EJVM%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%8E%A9%E6%84%8F%E5%84%BF/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="关于JVM，你必须知道的那些玩意儿"><meta property="og:url" content="http://yoursite.com/2020/06/24/%E5%85%B3%E4%BA%8EJVM%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%8E%A9%E6%84%8F%E5%84%BF/"><meta property="og:site_name" content="ClericYi's Blog"><meta property="og:description" content="类的加载机制先使用一张图整个加载机制所包含的过程。  通过这张图我们可以了解到，关于类的加载其实就是可以分为五个大阶段，不过下面文中主要从加载、验证、准备、解析还有初始化这五个方面来做一个讲解： 加载需要完成以下三项任务：  （1）通过一个类的全限定名来获取定义此类的二进制字节流。（并没有指定数据必须从Class文件中获取） （2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-06-24T07:28:31.883Z"><meta property="article:modified_time" content="2020-06-24T07:28:43.546Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="next" title="锦囊篇｜一文摸懂RxJava" href="http://yoursite.com/2020/06/24/%E9%94%A6%E5%9B%8A%E7%AF%87%EF%BD%9C%E4%B8%80%E6%96%87%E6%91%B8%E6%87%82RxJava/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#类的加载机制"><span class="toc-number">1.</span> <span class="toc-text">类的加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#加载"><span class="toc-number">1.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#验证"><span class="toc-number">1.2.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#准备"><span class="toc-number">1.3.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解析"><span class="toc-number">1.4.</span> <span class="toc-text">解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化"><span class="toc-number">1.5.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类加载器"><span class="toc-number">2.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#双亲委派模型"><span class="toc-number">3.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理"><span class="toc-number">3.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#破坏双亲委派模型"><span class="toc-number">3.2.</span> <span class="toc-text">破坏双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何开展破坏活动"><span class="toc-number">3.2.1.</span> <span class="toc-text">如何开展破坏活动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#溯源ClassLoader-getSystemClassLoader"><span class="toc-number">3.3.</span> <span class="toc-text">溯源ClassLoader.getSystemClassLoader()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java内存模型"><span class="toc-number">4.</span> <span class="toc-text">Java内存模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GC回收机制"><span class="toc-number">5.</span> <span class="toc-text">GC回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#堆区的细节划分"><span class="toc-number">5.1.</span> <span class="toc-text">堆区的细节划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象存活判断"><span class="toc-number">5.2.</span> <span class="toc-text">对象存活判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引用计数"><span class="toc-number">5.2.1.</span> <span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可达性分析"><span class="toc-number">5.2.2.</span> <span class="toc-text">可达性分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回收算法"><span class="toc-number">5.3.</span> <span class="toc-text">回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复制收集"><span class="toc-number">5.3.1.</span> <span class="toc-text">复制收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记清理"><span class="toc-number">5.3.2.</span> <span class="toc-text">标记清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记整理"><span class="toc-number">5.3.3.</span> <span class="toc-text">标记整理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于垃圾回收器"><span class="toc-number">5.4.</span> <span class="toc-text">关于垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四大引用"><span class="toc-number">6.</span> <span class="toc-text">四大引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><div class="code-close" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">ClericYi's Blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">关于JVM，你必须知道的那些玩意儿</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-24 15:28:31"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-06-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-24 15:28:43"><i class="fas fa-history fa-fw"></i> 更新于 2020-06-24</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/9/17298a294a672707?w=1420&h=1104&f=png&s=105326" alt=""></p>
<h1 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h1><p>先使用一张图整个加载机制所包含的过程。</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/8/17292de0c52cb8ff?w=926&h=303&f=jpeg&s=38820" alt=""></p>
<p>通过这张图我们可以了解到，关于类的加载其实就是可以分为五个大阶段，不过下面文中主要从加载、验证、准备、解析还有初始化这五个方面来做一个讲解：</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>需要完成以下三项任务： </p>
<p><strong>（1）通过一个类的全限定名来获取定义此类的二进制字节流。（并没有指定数据必须从Class文件中获取）</strong></p>
<p><strong>（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</strong></p>
<p><strong>（3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</strong></p>
<p> 往简单了说，就是从文件中读取二进制数据，对获取到的二进制数据做一个转化，变成一个JVM能够认识的模样，<strong>也就是方法区运行时的数据结构</strong>，然后JVM中生成对应的内存空间作为入口，到时候各类数据的入口。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><blockquote>
<p>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
</blockquote>
<p>为什么需要这么一个环节呢？ <strong>Class文件的产生，并不是一定来自Java源码。</strong> 他甚至可以由我们直接编写而成，验证能帮我过滤掉错误的Class文件，保障虚拟机的正确运行。</p>
<p><strong>需要完成以下四项任务：</strong></p>
<p> <strong>（1）文件格式验证：</strong> 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p>
<p><strong>（2）元数据验证：</strong> 对类的元数据信息中的数据类型等进行校验。 </p>
<p><strong>（3）字节码验证：</strong> 对类的方法体进行校验，确保程序语义的合法性。</p>
<p><strong>（4）符号引用验证：</strong> 保证解析动作的正确执行。<strong>（动作在解析时发生）</strong></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote>
<p>正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
</blockquote>
<p>这个阶段存在一个思考。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> i_final_static = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i_static = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Q1：为什么我们可以直接从<code>main()</code>函数中调用到的<code>i_static</code>，而调用不到i呢？</strong></p>
<p><strong>A1：</strong> 作为读者的你肯定会说，这不是废话吗，<code>i_static</code>是用<code>static</code>修饰的，当然可以调用。但是这是从使用的角度来思考了。 </p>
<p>其实这就是准备阶段要干的事情了，在这个阶段，虚拟机已经为这些数据做好了存放的工作，所以我们能够调用。但是<code>i</code>这个变量，在你没有实例化之前，他是没有被存放在内存空间的，自然也就不能够调用了。更直白的说，就是你找不到呗，找不到我怎么用。</p>
<p><strong>Q2：那如果<code>i_final_static</code>和<code>i_static</code>呢，他们又会有什么样的区别？</strong></p>
<p><strong>A2：</strong> 这两个在准备阶段的值分别是0和123。这是因为对于没有<code>final</code>修饰的类而言，数据只有在初始化时通过<code>putstatic</code>的指令才会进行赋值，而<code>final</code>的作用是将数据存放在了<code>ConstantValue</code>的属性中，这样就在准备阶段时数据就已经准备完毕了。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><blockquote>
<p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
</blockquote>
<ul>
<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>
</ul>
<p>解析是一个不定时的工作内容，因为像<code>new</code>，数组引用这些都是一个视情况而定的事件。他所针对的动作有类、接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</strong> </p>
<p><strong>Q1：那么<code>&lt;clinit&gt;()</code>干的活到底是什么呢？</strong></p>
<p>编译器自动收集类中的所有类变量的赋值动作和静态语句块 <strong>（static{}）</strong> 组合产生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public static int i_static = 123;</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i_static = <span class="number">0</span>;</span><br><span class="line">        System.out.println(i_static); <span class="comment">// 如果变量在后面定义出现非法前向引用报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i_static = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过我感觉变量在静态语句块之后定义好像没什么用🤔🤔🤔🤔，毕竟结果告诉我们谁定义在后头，值就是谁的。</p>
<p>看完了静态语句块的一些内容，我们就要加入父子类继续判定它的加载顺序了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bean类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean static load"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Bean()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean load"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自Bean的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanSon</span> <span class="keyword">extends</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"BeanSon static load"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanSon()&#123;</span><br><span class="line">        System.out.println(<span class="string">"BeanSon load"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体调用</span></span><br><span class="line">Bean bean = <span class="keyword">new</span> BeanSon();</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/1706726ab2b5be1a?w=720&h=97&f=png&s=5252" alt=""></p>
<p>可以发现加载的优先顺序如下：</p>
<ul>
<li>静态 &gt; 实例；</li>
<li>父类 &gt; 子类</li>
</ul>
<p>另外一个是我在牛客练习时知道的知识，叫做左编译右运行，其实是向上转型的概念，但是这种记法更生动形象。</p>
<p>直接用代码来验证这句话，现在将子类和父类修改成以下形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanSon</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanSon</span> <span class="keyword">extends</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"BeanSon static load"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanSon() &#123;</span><br><span class="line">        System.out.println(<span class="string">"BeanSon load"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commonHas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"commonHas BeanSon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"doSomething"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean static load"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Bean()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean load"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commonHas</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"commonHas Bean"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用上面的Main类中的对象bean去调用这个函数，会出现什么情况？</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/1706726ab39edc0f?w=1240&h=578&f=png&s=112125" alt=""></p>
<p>找不到<code>doSomething()</code>这个函数？这就是左编译的意思了，虽然是按照右边的子类运行，但是是不会将子类多出来的方法加入到方法区。<br>再调用上图中的<code>commonHas()</code>方法后，你又会发现打印的结果是这样的。<br><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/1706726ab436c252?w=1240&h=307&f=png&s=47160" alt=""></p>
<p>它运行出了子类的结果，这也就是右运行的意思了。</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>在Java虚拟机中，类加载器十分重要。每一个类的加载，都需要通过一个类的加载器。但是如果我们创建一个属于自己的类加载器，这个时候会出现一个什么样的情况呢？<br>接下来，我们用代码来进行验证测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 由自己的类加载器创建对象</span></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">"XuNiJi.ClassLoaderTest"</span>).newInstance();</span><br><span class="line">        <span class="comment">// 由系统提供的类加载器加载创建对象</span></span><br><span class="line">        Object obj1 = ClassLoader.getSystemClassLoader().loadClass(<span class="string">"XuNiJi.ClassLoaderTest"</span>).newInstance();</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> ClassLoaderTest);</span><br><span class="line">        System.out.println(obj1 <span class="keyword">instanceof</span> ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/1706727209b96526?w=1240&h=412&f=png&s=45697" alt=""><br>从这里想来已经能够看出了，由一个类加载器统一创建的类，才存在可比性。因为类加载器是拥有独立的类名称空间的。更简单的说，就像上面的例子，如果不使用Java虚拟机提供的类加载器，你就会失去一大部分功能，比如<code>equals()</code>、<code>isAssignableFrom()</code>、<code>isInstance()</code>、<code>instanceof</code>。如果要相同，除非你直接在java源码上动手脚。</p>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p><strong>Q1：为什么需要这个模型？</strong></p>
<p>其实这个模型的提出，就是为了解决类加载器可能不出现不同的问题。因为即便是相同的<code>class</code>，由不同的类加载器加载时，结果就是不同的。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>双亲委派的工作流程非常简单，这就跟之前文章里的Android的事件分发机制一样，向上传递，由父类加载器先行尝试消费，如果父类无法完成这个任务，那么子加载器就要由自己动手完成。</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/17067272067d5bfa?w=874&h=758&f=png&s=357167" alt=""></p>
<blockquote>
<ol>
<li>启动类加载器：负责加载/lib下的类。</li>
<li>扩展类加载器：负责加载/lib/ext下的类。</li>
<li>系统类加载器/应用程序类加载器：<code>ClassLoader.getSystemClassLoader</code>返回的就是它。</li>
</ol>
</blockquote>
<p>通过上图我们可以知道，子加载器不断的给上一层加载器传递加载请求，那么这个时候启动类加载器势必是接受到过全部的加载请求的。如果不信，我们就用源码来证明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 判断Class是否被加载过</span></span><br><span class="line">            <span class="comment">// 说明被加载的Class其实是制作一个缓存的</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果父类抛出ClassNotFoundException</span></span><br><span class="line">                    <span class="comment">// 说明父类无法完成加载</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这个时候c依旧为null，说明父类加载不了</span></span><br><span class="line">                <span class="comment">// 那没有办法，只能子加载器自己效劳了</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>讲完了他的工作原理，自然就要知道，他能够如何被破坏的了。</p>
<h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p><strong>Q2：为什么要破坏双亲委派？</strong></p>
<p>拿最简单的例子，在上文中我们，提到过各个资源的加载范围，但是<code>Driver</code>作为后来才加入的一个接口，他的很多api是由第三方服务商开发的。那么这个时候，破坏双亲委派就有了他的用武之地了，当然这只是他的用处之一。</p>
<p>下面来介绍，他是如何破坏双亲委派的。</p>
<h3 id="如何开展破坏活动"><a href="#如何开展破坏活动" class="headerlink" title="如何开展破坏活动"></a>如何开展破坏活动</h3><p>先看看我们平时都是怎么用的。（当然这是很基础的写法了，因为现在池的概念加深，所以很多事情都已经被封装了。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/db"</span>;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br></pre></td></tr></table></figure>
<p>上面很明显就能看出这件事情就是关于<code>DriverManager</code>展开的了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据前一章的内容先要对<code>DriverManager</code>进行初始化，也就是调用了一个<code>loadInitialDrivers()</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        .....</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// 1</span></span><br><span class="line">                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">                <span class="comment">// 。。。。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这一小段中，我们关注<code>注释1</code>能够知道他专门去访问了一个<code>ServiceLoader</code>的类，点进去之后我们能够发现这么三段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">        service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">        <span class="comment">// 两种选择</span></span><br><span class="line">        <span class="comment">// 1. 使用系统的加载器 - ClassLoader.getSystemClassLoader()</span></span><br><span class="line">        <span class="comment">// 2. 使用线程上下文加载器 — cl</span></span><br><span class="line">        loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">        acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">        reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由1 –&gt; 2 –&gt; 3的顺序循序渐进，你是否已经和我关注到一个问题了！！什么叫做线程上下文加载器 <strong>（Thread.currentThread().getContextClassLoader()）</strong>？</p>
<p>线程上下文类加载器在<code>Java 2</code>时引入。每个线程都有一个关联的上下文类加载器。如果你通过<code>new Thread()</code>方式来创建新的线程，新线程将继承其父线程的上下文类加载器。如果程序对线程上下文类加载器没有任何改动的话，程序中所有的线程将都使用应用程序类加载器作为上下文类加载器。但是对于三方库而言，应用类加载器去完成子类加载器才能完成的任务显然是不可能的，这就需要<code>Oracle</code>给三方提供的入口，也就是<code>Thread.currentThread().setContextClassLoader();</code>的方法，让我有了自定义的空间，这也就有机会去完成我们想要的双亲委派破坏了。</p>
<h2 id="溯源ClassLoader-getSystemClassLoader"><a href="#溯源ClassLoader-getSystemClassLoader" class="headerlink" title="溯源ClassLoader.getSystemClassLoader()"></a>溯源ClassLoader.getSystemClassLoader()</h2><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/17067272037aa057?w=996&h=388&f=png&s=52489" alt=""></p>
<p>这张图里我们只用关注圈红的<code>initSystemClassLoader()</code>函数。<br><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/170672720a2aa7c8?w=986&h=180&f=png&s=38914" alt=""></p>
<p>然后在<code>initSystemClassLoader()</code>函数中调用了一个<code>Launcher</code>的类。<br><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/1706727206c2c102?w=1240&h=496&f=png&s=168402" alt=""></p>
<p>而<code>Launcher</code>整个类的创建，想来读者也已经看到<code>loader</code>这个变量了，通过<code>getAppClassLoader()</code>这个函数所创建的<code>loader</code>也就是我们口中所说的应用程序类加载器了，这也从源码上讲述了双亲委派机制的存在。</p>
<p>另外<code>Thread.currentThread().setContextClassLoader(this.loader);</code>证明了一点，就是关于线程上下文加载器默认的就是应用程序类加载器。</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>在此之前我们需要知道GC回收机制回收的是什么？他们的存储形式是什么样的？等等一系列问题。所以引入了内存模型的概念。<br><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/170672773bb0a92f?w=1240&h=797&f=png&s=232679" alt="Java内存模型"></p>
<p><strong>5大区域各自的作用：</strong></p>
<ol>
<li>程序计数器：指示当前线程所执行的字节码执行到了第几行。</li>
<li>虚拟机栈：为执行的方法创建栈帧，保存了局部变量表、操作站、动态链接、方法出口等信息，主要用来执行Java方法。</li>
<li>本地方法栈：运行方法与虚拟机栈相似，主要用来执行native方法。</li>
<li>堆区：用于存储对象的实例。</li>
<li>方法区：存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。</li>
</ol>
<p><code>Object</code>作为所有类的父类以他创建一个对象，将涉及哪些区域的变动呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>① <code>Object obj</code>表示一个本地引用，存储在虚拟机栈的本地变量表中，表示一个<code>reference</code>类型数据；</p>
<p>② <code>new Object()</code>作为实例对象数据存储在堆中，另外还记录了<code>Object</code>类的类型信息（接口、方法、field、对象类型等）的地址，这些地址所执行的数据存储在方法区中；</p>
<h1 id="GC回收机制"><a href="#GC回收机制" class="headerlink" title="GC回收机制"></a>GC回收机制</h1><p>既然要垃圾回收，那到底要回收的是哪些东西呢？<br>上文中<code>Object</code>类的举例，已经有一定的苗头了。<br>在方法区中的数据，是从一开始就要求被加入的，那么回收掉他们难免会出现各种问题。而像<code>Object</code>这样的类，只在一段时间内需要被使用，也就难免会成为多出来的碎片，也就成了典型的“占着茅坑不拉屎”的了。<br>所以，显而易见，我们要回收的就是这么一类垃圾数据了，而GC回收器回收的也就是这种<code>new</code>出来以后没用了的数据了。</p>
<h2 id="堆区的细节划分"><a href="#堆区的细节划分" class="headerlink" title="堆区的细节划分"></a>堆区的细节划分</h2><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/170672773bafeaca?w=1052&h=370&f=png&s=226110" alt=""></p>
<ul>
<li><p><strong>新生代：</strong> <code>Eden</code> 、<code>From Space</code>、<code>To Space</code><br>刚创建的对象一般都被放入<code>Eden</code>中，<code>Eden</code>满了以后，就会进行一次<code>GC</code>操作，删去消亡的，把活跃的放到<code>From</code>中。<strong>（<code>To Space</code>和<code>From Space</code>是一个轮换的，空的那份数据就是下一轮Eden满时要存放数据的From Space，另外一个就成了To Spcae）</strong> <code>To Space</code>满了的时候就会将对象转移到老年代。</p>
</li>
<li><p><strong>老年代：</strong> 经过了多次回收，但还是坚强存活下来的对象们所在的内存空间。</p>
</li>
</ul>
<h2 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>一个对象被引用时加一，被去除引用时减一。那么当数值为0时，这个引用就成为了一个垃圾。</p>
<p><strong>但是，如果存在循环引用时，就不会结束引用。</strong><br><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/5/17282fdaa5f7cf43?w=844&h=520&f=png&s=35795" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A类持有B的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B类同样持有A的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体使用</span></span><br><span class="line"><span class="comment">// 但是在测试中是可以回收的，因为我们JVM使用的并不是引用计数法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        a.b = b;</span><br><span class="line">        b.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>和引用计数法比较，可达性分析法多了一个叫做<code>GC Root</code>的概念，而这些<code>GC Roots</code>就是我们可达性分析法的起点，在周志明前辈的《深入理解Java虚拟机》中就已经提到过了这个概念，它主要分为几类：</p>
<ul>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池里的引用。</li>
<li>在本地方法栈中JNI引用的对象。</li>
<li>在Java虚拟机栈中引用的对象，譬如<code>Android</code>的主入口类<code>ActivityThread</code>。</li>
<li>所有被同步锁持有的对象。</li>
<li>。。。。。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/5/17282fdaaa897682?w=1100&h=320&f=png&s=50352" alt=""></p>
<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><h3 id="复制收集"><a href="#复制收集" class="headerlink" title="复制收集"></a>复制收集</h3><p>这是一个应用于<strong>新生代</strong>内存整理的方法。</p>
<p>因为新生代的Eden区是一个连续的内存空间 <strong>（占据新生代8成）</strong>，通过遍历，把这个内存空间的消亡的对象删去，活跃的对象们重新放入一个新的空白内存空间中，也就是<code>To Space</code>和<code>From Space</code>的相互交换，各占据1成空间，另外需要注意的是<code>To Space</code>和<code>From Space</code>不是固定的，两个空间的名称可以互换，因为数据总是在这两个区间中越迁。</p>
<p><strong>存在问题：内存折半。</strong></p>
<h3 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h3><p>这是一个应用于<strong>老年代</strong>内存整理的方法。<br><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/170672773bf1896a?w=1240&h=459&f=png&s=30279" alt=""></p>
<p>如图所示，搜索出活跃的对象，清除消亡对象。</p>
<p><strong>存在问题：会产生空间碎片。</strong></p>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>这是一个应用于<strong>老年代</strong>内存整理的方法。<br><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/2/21/170672773bd81fc6?w=1240&h=425&f=png&s=31032" alt=""></p>
<p>比标记清理算法多一点，他需要排序。</p>
<p><strong>存在问题：用性能换取空间碎片的整理。</strong></p>
<h2 id="关于垃圾回收器"><a href="#关于垃圾回收器" class="headerlink" title="关于垃圾回收器"></a>关于垃圾回收器</h2><ul>
<li><strong>Serial收集器：</strong> 历史最悠久的垃圾回收器了，他对应这一个词<code>“Stop The World”</code>,作为单线程的进行处理垃圾回收器，在它干活时，程序小弟们必须老老实实给我爬。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/9/172987bc2f140aaa?w=1112&h=227&f=jpeg&s=48345" alt=""></p>
<ul>
<li><p><strong>ParNew收集器：</strong> 本质上还是与<code>Serial收集器</code>相仿。对于老年代而言，同样采用的是<code>Stop The World</code>的方案，但是对于新生代，多线程的加入无疑是能够提高效率的方案，多线程中垃圾收集的时间能够成倍数下降，也就更能让用户感知不到卡顿感觉。<br><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/9/172987c005a96e6a?w=1112&h=230&f=jpeg&s=53583" alt=""></p>
</li>
<li><p><strong>Parallel Scanvenge收集器：</strong> 作为一款使用于新生代的收集器，使用的垃圾回收算法也就是我们上面已经提及到的复制算法。它提供了<code>-XX：MaxGCPauseMillis（最大垃圾收集停顿时间）</code>和<code>-XX：GCTimeRatio（吞吐量大小）</code>两个可控选项，但是要<strong>注意这两个选项，同时都小时，说明<code>GC</code>的次数会愈加频繁；而同时都大时，会导致卡顿感明显。</strong></p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/9/172988960d419076?w=1035&h=221&f=jpeg&s=47817" alt=""></p>
<ul>
<li><p><strong>Serial Old收集器：</strong> 是一款作用于老年代的垃圾收集器，使用的垃圾回收算法就是 <strong>标记-整理</strong> 。<br><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/9/1729887601db989e?w=1120&h=218&f=jpeg&s=49253" alt=""></p>
</li>
<li><p><strong>Parallel Old收集器：</strong> 同样是一款作用于老年代的垃圾收集器，使用的垃圾回收算法就是 <strong>标记-整理</strong> 。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/9/1729889769e4765a?w=1035&h=221&f=jpeg&s=47817" alt=""></p>
<ul>
<li><strong>CMS收集器：</strong> 它的重点时非常关注应用的相应速度，使用的回收算法是<strong>标记-整理</strong> 。它的工作分为四个步骤：<code>（1）初始标记。（2）并发标记。（3）重新标记。（4）并发清理</code>。其中，初始标记和重新标记是会发生<code>Stop The World</code>的，不过时间比较短。<ul>
<li><strong>三大缺憾：</strong> （1）对处理器资源的敏感，并且自己会占用去一部分线程，导致吞吐率下降。（2）无法处理标记完成以后出现的垃圾。（3）标记-清理算法的空间碎片问题</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/9/172988ae99c84c24?w=1114&h=226&f=jpeg&s=70575" alt=""></p>
<ul>
<li><strong>G1回收器：</strong> 同样的遵循年代划分的设计，但是面向的对象的回收策略以性价比作为了基准。图中的每一个空格也就是<code>Region</code>的大小是可以设定的，而作为大小的判断是通过当前对象占有的<code>Region</code>的大小占比来进行判定的，当然我们知道会出现这样的数据一次性占去了很多个<code>Region</code>，因为我们说过他终究是存在年代划分的，这样的数据绝大多数把他认为是老年代的数据。而对于数据回收一般会分为四个步骤：<code>（1）初始标记（2）并发标记（3）最终标记（4）筛选回收</code>。<blockquote>
<p>具体的操作步骤请看<strong>why技术</strong>的文章</p>
<p><a href="https://juejin.im/post/5e5b15f5f265da57602c547d" target="_blank" rel="noopener">面试官问我G1回收器怎么知道你是什么时候的垃圾？</a></p>
</blockquote>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/9/172989914a2d2801?w=653&h=483&f=jpeg&s=40812" alt=""></p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/6/9/172989cc3ab66742?w=1025&h=222&f=jpeg&s=64066" alt=""></p>
<h1 id="四大引用"><a href="#四大引用" class="headerlink" title="四大引用"></a>四大引用</h1><p>上面我们说到了回收器的存在，但是能否回收才决定了我们的回收算法是否生效，一般来说分为以下四类：</p>
<ul>
<li>强饮用：一般为使用关键词<code>new</code>实例化的对象，这类引用GC回收器宁可溢出，也不会回收。</li>
<li>软引用：有用但是不必要的对象们，只有在内存不足时，才会被GC回收器回收。一般使用于缓存各种资源。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SoftReference&lt;String&gt; sr = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"SoftReference"</span>));</span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>弱引用：GC发生时就会被回收的对象们，是一种防治oom的方法。弱引用的应用场景在我的 <a href="https://github.com/ClericYi/helper" target="_blank" rel="noopener">Android工具包MVP框架</a> 中使用到，另外在上次的 <a href="https://juejin.im/post/5ecb1c52518825434b1fb7b4" target="_blank" rel="noopener">锦囊篇｜一文摸懂LeakCanary</a> 中也有提及。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakReference&lt;String&gt; sr = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"WeakReference"</span>));</span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">        <span class="comment">// gc回收后再次查看效果</span></span><br><span class="line">        System.gc();                </span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>虚引用：形同虚设的引用。</li>
</ul>
<p><strong>上面三种讲的很清楚了，但是这个虚引用到底有什么用呢？</strong></p>
<p>它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。我个人认为可以和弱引用一样做一个内存泄漏检查的解决方案，但是还不清楚他的缺憾在哪儿。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》 – 周志明</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cleric Yi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/06/24/%E5%85%B3%E4%BA%8EJVM%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%8E%A9%E6%84%8F%E5%84%BF/">http://yoursite.com/2020/06/24/%E5%85%B3%E4%BA%8EJVM%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%8E%A9%E6%84%8F%E5%84%BF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">ClericYi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/06/24/%E9%94%A6%E5%9B%8A%E7%AF%87%EF%BD%9C%E4%B8%80%E6%96%87%E6%91%B8%E6%87%82RxJava/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">锦囊篇｜一文摸懂RxJava</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Cleric Yi</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>