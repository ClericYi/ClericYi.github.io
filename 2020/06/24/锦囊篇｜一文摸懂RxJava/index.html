<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>锦囊篇｜一文摸懂RxJava | ClericYi's Blog</title><meta name="description" content="前言于3月14号，RxJava开源了他的第三个版本。 这个版本中，更新了一下的内容： （1）包结构变化RxJava 3 components are located under the io.reactivex.rxjava3 package (RxJava 1 has rx and RxJava 2 is just io.reactivex. This allows version 3 to"><meta name="author" content="Cleric Yi"><meta name="copyright" content="Cleric Yi"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://yoursite.com/2020/06/24/%E9%94%A6%E5%9B%8A%E7%AF%87%EF%BD%9C%E4%B8%80%E6%96%87%E6%91%B8%E6%87%82RxJava/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="锦囊篇｜一文摸懂RxJava"><meta property="og:url" content="http://yoursite.com/2020/06/24/%E9%94%A6%E5%9B%8A%E7%AF%87%EF%BD%9C%E4%B8%80%E6%96%87%E6%91%B8%E6%87%82RxJava/"><meta property="og:site_name" content="ClericYi's Blog"><meta property="og:description" content="前言于3月14号，RxJava开源了他的第三个版本。 这个版本中，更新了一下的内容： （1）包结构变化RxJava 3 components are located under the io.reactivex.rxjava3 package (RxJava 1 has rx and RxJava 2 is just io.reactivex. This allows version 3 to"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-06-24T04:57:00.333Z"><meta property="article:modified_time" content="2020-06-24T04:58:52.653Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="关于JVM，你必须知道的那些玩意儿" href="http://yoursite.com/2020/06/24/%E5%85%B3%E4%BA%8EJVM%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%8E%A9%E6%84%8F%E5%84%BF/"><link rel="next" title="锦囊篇｜一文摸懂EventBus" href="http://yoursite.com/2020/06/24/%E9%94%A6%E5%9B%8A%E7%AF%87%EF%BD%9C%E4%B8%80%E6%96%87%E6%91%B8%E6%87%82EventBus/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#What-is-RxJava？"><span class="toc-number">2.</span> <span class="toc-text">What is RxJava？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用方法"><span class="toc-number">3.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RxJava背压"><span class="toc-number">4.</span> <span class="toc-text">RxJava背压</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#对应源码中的基本使用"><span class="toc-number">4.1.</span> <span class="toc-text">对应源码中的基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BackpressureStrategy-背压策略"><span class="toc-number">4.2.</span> <span class="toc-text">BackpressureStrategy&#x2F;背压策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#四大策略对应结果"><span class="toc-number">4.2.1.</span> <span class="toc-text">四大策略对应结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程控制"><span class="toc-number">5.</span> <span class="toc-text">线程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用方法-1"><span class="toc-number">5.1.</span> <span class="toc-text">使用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作符的使用"><span class="toc-number">6.</span> <span class="toc-text">操作符的使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码导读"><span class="toc-number">7.</span> <span class="toc-text">源码导读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Observable-create"><span class="toc-number">7.1.</span> <span class="toc-text">Observable.create</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#subscribe"><span class="toc-number">7.2.</span> <span class="toc-text">subscribe</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateEmitter"><span class="toc-number">7.2.1.</span> <span class="toc-text">CreateEmitter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#source-subscribe-parent"><span class="toc-number">7.3.</span> <span class="toc-text">source.subscribe(parent);</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步通信"><span class="toc-number">7.4.</span> <span class="toc-text">异步通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RxJava的异步通信原理"><span class="toc-number">7.4.1.</span> <span class="toc-text">RxJava的异步通信原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#observeOn-的线程切换原理"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">observeOn() 的线程切换原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#subscribeOn-的线程切换原理"><span class="toc-number">7.4.1.2.</span> <span class="toc-text">subscribeOn() 的线程切换原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RxAndroid是如何完成异步的通信的？"><span class="toc-number">7.4.2.</span> <span class="toc-text">RxAndroid是如何完成异步的通信的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AndroidSchedulers-mainThread"><span class="toc-number">7.4.3.</span> <span class="toc-text">AndroidSchedulers.mainThread()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">9.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><div class="code-close" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">ClericYi's Blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">锦囊篇｜一文摸懂RxJava</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-24 12:57:00"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-06-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-24 12:58:52"><i class="fas fa-history fa-fw"></i> 更新于 2020-06-24</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/5/9/171f9fba7ed37857?imageView2/0/w/1280/h/960/ignore-error/1" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>于3月14号，RxJava开源了他的第三个版本。</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/5/9/171f7d9c173524bb?w=1178&h=458&f=png&s=107142" alt=""><br>这个版本中，更新了一下的内容：</p>
<p><strong>（1）包结构变化</strong><br><code>RxJava 3 components are located under the io.reactivex.rxjava3 package (RxJava 1 has rx and RxJava 2 is just io.reactivex. This allows version 3 to live side by side with the earlier versions. In addition, the core types of RxJava (Flowable, Observer, etc.) have been moved to io.reactivex.rxjava3.core.</code><br>为了阅读障碍的朋友们给出我的一份四级水准翻译，有以下的几点变化：</p>
<ol>
<li>文件迁移。RxJava3的组件迁移至包<code>io.reactivex.rxjava3</code>中</li>
<li>向前兼容。</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/5/9/171f7da3b3ecbc50?w=1176&h=918&f=png&s=544668" alt=""></p>
<p><strong>（2）行为变化。</strong> 针对一些现有错误的纠正等。</p>
<p><strong>（3）API变化。</strong> <code>@FunctionalInterface</code>注解的使用等</p>
<blockquote>
<p>详细见于文档：<a href="https://github.com/ReactiveX/RxJava/wiki/What' target="_blank" rel="noopener"s-different-in-3.0">What’s different in 3.0</a></p>
</blockquote>
<p>就整体来说我们的基本开发功能没有很大的改变。</p>
<h1 id="What-is-RxJava？"><a href="#What-is-RxJava？" class="headerlink" title="What is RxJava？"></a>What is RxJava？</h1><p>RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.</p>
<p>RxJava 是一个在 Java VM 上使用可观测的序列来组成异步、且基于事件的程序的库。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>基于事件流的链式调用完成订阅</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Observable.create&lt;String&gt; &#123;</span><br><span class="line">            it.onNext(<span class="string">"items：1"</span>)</span><br><span class="line">            it.onNext(<span class="string">"items：2"</span>)</span><br><span class="line">            it.onError(Exception())</span><br><span class="line">            it.onComplete()</span><br><span class="line">        &#125;.subscribe(object : Observer&lt;String&gt; &#123;</span><br><span class="line">            <span class="function">override fun <span class="title">onSubscribe</span><span class="params">(d: Disposable)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"subscribe事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">override fun <span class="title">onNext</span><span class="params">(s: String)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Next事件：$s"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">override fun <span class="title">onError</span><span class="params">(e: Throwable)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Error事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">override fun <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Complete事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>我们能够看到几个特别显眼的类和方法。</p>
<ol>
<li><strong>Observable：</strong> 被观察者</li>
<li><strong>Observer：</strong> 观察者</li>
<li><strong>Subscribe：</strong> 订阅</li>
<li><strong>Disposable：</strong> 断连。在类出现的函数中加入<code>d.dispose()</code>这一段代码，就能够让连接断开。</li>
</ol>
<p><strong>是否有这样的一个问题，为什么会是被观察者订阅观察者？</strong></p>
<p>为了更好的理解我们将这<code>Observable</code>、<code>Observer</code>、<code>Subscribe</code>这三者对应到我们生活中，分别是顾客、厨师、服务员。顾客告诉服务员想吃什么，服务员告诉厨师要做什么。</p>
<p><strong>接下来又出现了另外一个问题，如果我们的厨师忙不过来了呢？</strong> 想来这也是日常生活中非常容易遇到的问题了，顾客太多，厨师又只有那么几个，导致厨师忙的晕头转向了。那RxJava同样的是存在这样的问题的，处理速度一定，但是被观察者的数据量过大，我们该如何去进行处理呢？这就引出了背压的概念。</p>
<h1 id="RxJava背压"><a href="#RxJava背压" class="headerlink" title="RxJava背压"></a>RxJava背压</h1><p>上文中我们知道了RxJava要有背压的原因，这里我们再图解一下。</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/5/9/171f7dac16a4ffd2?w=1190&h=718&f=png&s=169654" alt=""></p>
<p>长时间出现这样的情况使得消息的堆叠，就可能会导致应用因<code>OOM</code>而崩溃。</p>
<p>在看源码的解决方案之前，我们先进行一个思考，请看下图：</p>
<blockquote>
<p><strong>注：</strong> 并不直接对应实际代码</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/5/9/171f7daf5fa4c1b2?w=1190&h=606&f=png&s=123876" alt=""></p>
<h2 id="对应源码中的基本使用"><a href="#对应源码中的基本使用" class="headerlink" title="对应源码中的基本使用"></a>对应源码中的基本使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create&lt;Int&gt;(&#123; emitter -&gt;</span><br><span class="line">            <span class="comment">// 一共发送129个事件，即超出了缓存区的大小</span></span><br><span class="line">            <span class="comment">// 将数值128改成0来观察一下变化</span></span><br><span class="line">            <span class="keyword">for</span> (i in <span class="number">0</span>..<span class="number">128</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"发送了事件$i"</span>)</span><br><span class="line">                emitter.onNext(i)</span><br><span class="line">            &#125;</span><br><span class="line">            emitter.onComplete()</span><br><span class="line">        &#125;, BackpressureStrategy.ERROR) <span class="comment">// 背压策略加入</span></span><br><span class="line">        .subscribe(object : Subscriber&lt;Int&gt; &#123;</span><br><span class="line">                <span class="function">override fun <span class="title">onSubscribe</span><span class="params">(s: Subscription)</span> </span>&#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"onSubscribe"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">override fun <span class="title">onNext</span><span class="params">(integer: Int)</span> </span>&#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"接收到了事件$integer"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">override fun <span class="title">onError</span><span class="params">(t: Throwable)</span> </span>&#123;</span><br><span class="line">                    Log.w(TAG, <span class="string">"onError: "</span>, t)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">override fun <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"onComplete"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>
<p>从源码中可以看到这样的一些使用：</p>
<ol>
<li><strong>Flowable：</strong> 也就是背压的实现类</li>
<li><strong>Subscriber：</strong> 订阅，和<code>Observer</code>差不多，但是多了一些适配<code>Flowable</code>的功能</li>
<li><strong>BackpressureStrategy：</strong> 着重讲解。</li>
</ol>
<h2 id="BackpressureStrategy-背压策略"><a href="#BackpressureStrategy-背压策略" class="headerlink" title="BackpressureStrategy/背压策略"></a>BackpressureStrategy/背压策略</h2><p>这也就是我们上文中所思考的问题了，现在先看看RxJava给我们提供了什么样的方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BackpressureStrategy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提示缓存区已满</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MISSING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认模式，数据超出缓存的128时，抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ERROR,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无限缓存，可能会OOM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BUFFER,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超出128时进行丢弃后面进来的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DROP,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超出128时进行丢弃最开始进来的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LATEST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四大策略对应结果"><a href="#四大策略对应结果" class="headerlink" title="四大策略对应结果"></a>四大策略对应结果</h3><ol>
<li><strong>MISSING</strong></li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/1/17/16101914d05027ac?imageView2/0/w/1280/h/960/ignore-error/1" alt=""><br>2. <strong>ERROR</strong></p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/1/17/16101914b5aec75d?imageView2/0/w/1280/h/960/ignore-error/1" alt=""><br>3. <strong>BUFFER：</strong> 成功发送了128的事件</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/1/17/16101914cf598f68?imageView2/0/w/1280/h/960/ignore-error/1" alt=""><br>4. <strong>DROP：</strong> 只能获取到127数据<br><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/1/17/16101914deb46a6f?imageslim" alt=""><br>5. <strong>LATEST：</strong> 获取到最后发送的数据，也就是149</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/1/17/16101914efd2e240?imageslim" alt=""></p>
<h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><p>讲过了上面的内容，是否有主意要过另一个非常重要的知识点，也就是<strong>线程该怎么做？</strong> </p>
<p>在Android的开发过程中我们一直已经都有一个强烈的概念叫做耗时任务不要放在UI线程来运作，那我们的RxJava呢？回到我们上述的代码中，做一个实验进行一下观察。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.create&lt;String&gt; &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Observable的工作线程："</span> + Thread.currentThread().name)</span><br><span class="line">        &#125;.subscribe(object : Observer&lt;String&gt; &#123;</span><br><span class="line">            <span class="function">override fun <span class="title">onSubscribe</span><span class="params">(d: Disposable)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"subscribe事件"</span>);</span><br><span class="line">                Log.e(TAG, <span class="string">"Observer的工作线程："</span> + Thread.currentThread().name)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">override fun <span class="title">onNext</span><span class="params">(s: String)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Next事件：$s"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">override fun <span class="title">onError</span><span class="params">(e: Throwable)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Error事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">override fun <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Complete事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/5/9/171f7dc3deaec1fd?w=1190&h=92&f=png&s=105894" alt=""><br>从图中明显能够看出，当前的工作线程为<code>main</code>，也就是主线程。</p>
<p>？？？？那不是糟了，我们的耗时任务在主线程中进行完成的时候，不就会<code>ANR</code>的问题了？自然就需要找一个解决方案了。</p>
<p>那我们先来看看第一种，自我掩盖式。在上述的代码外加一层<code>Thread</code>。</p>
<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/5/9/171f7dcedc7254fa?w=1192&h=86&f=png&s=104693" alt=""><br>图中显示到工作线程切换了，但是如何进行UI的数据更新就又成了一个问题了,当然我们还是可以自己加入<code>Handler</code>来解决问题的。</p>
<p>为了解决这样的问题，<code>RxJava</code>给了我们一个很好的解决方案，也就是<code>subscribeOn() &amp; observeOn()</code>，以及一些已经定义好的场景内容。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Schedulers.immediate()</td>
<td align="center">当前线程 = 不指定线程</td>
<td align="center">默认</td>
</tr>
<tr>
<td align="center">AndroidSchedulers.mainThread()</td>
<td align="center">Android主线程</td>
<td align="center">操作UI</td>
</tr>
<tr>
<td align="center">Schedulers.newThread()</td>
<td align="center">常规新线程</td>
<td align="center">耗时等操作</td>
</tr>
<tr>
<td align="center">Schedulers.io()</td>
<td align="center">io操作线程</td>
<td align="center">网络请求、读写文件等io密集型操作</td>
</tr>
<tr>
<td align="center">Schedulers.computation()</td>
<td align="center">CPU计算操作线程</td>
<td align="center">大量计算操作</td>
</tr>
</tbody></table>
<h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Observable.create&lt;String&gt; &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Observable的工作线程："</span> + Thread.currentThread().name)</span><br><span class="line">        &#125;</span><br><span class="line">            .subscribeOn(Schedulers.newThread())</span><br><span class="line">            .observeOn(Schedulers.io())</span><br><span class="line">            .subscribe(object : Observer&lt;String&gt; &#123;</span><br><span class="line">            <span class="function">override fun <span class="title">onSubscribe</span><span class="params">(d: Disposable)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"subscribe事件"</span>);</span><br><span class="line">                Log.e(TAG, <span class="string">"Observer的工作线程："</span> + Thread.currentThread().name)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">override fun <span class="title">onNext</span><span class="params">(s: String)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Next事件：$s"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">override fun <span class="title">onError</span><span class="params">(e: Throwable)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Error事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">override fun <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Complete事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/5/9/171f7db5a4a6b975?w=1100&h=76&f=png&s=107074" alt=""></p>
<h1 id="操作符的使用"><a href="#操作符的使用" class="headerlink" title="操作符的使用"></a>操作符的使用</h1><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/5/9/171f7dbcb77329ec?w=1190&h=974&f=png&s=153351" alt=""><br>当然这里我就不做这么多的Demo了，建议直接看看<code>Carson_Ho</code>大佬的文章，下面是各个对应的链接：</p>
<ul>
<li>创建操作符：<a href="https://www.jianshu.com/p/e19f8ed863b1" target="_blank" rel="noopener">https://www.jianshu.com/p/e19f8ed863b1</a></li>
<li>变换操作符：<a href="https://www.jianshu.com/p/904c14d253ba" target="_blank" rel="noopener">https://www.jianshu.com/p/904c14d253ba</a></li>
<li>组合/合并操作符：<a href="https://www.jianshu.com/p/c2a7c03da16d" target="_blank" rel="noopener">https://www.jianshu.com/p/c2a7c03da16d</a></li>
<li>功能操作符：<a href="https://www.jianshu.com/p/b0c3669affdb" target="_blank" rel="noopener">https://www.jianshu.com/p/b0c3669affdb</a></li>
<li>过滤操作符：<a href="https://www.jianshu.com/p/c3a930a03855" target="_blank" rel="noopener">https://www.jianshu.com/p/c3a930a03855</a></li>
<li>条件/布尔操作符：<a href="https://www.jianshu.com/p/954426f90325" target="_blank" rel="noopener">https://www.jianshu.com/p/954426f90325</a></li>
</ul>
<h1 id="源码导读"><a href="#源码导读" class="headerlink" title="源码导读"></a>源码导读</h1><p>接下来我们就拿上面一份简单源码的使用过程进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Observable.create&lt;String&gt; &#123;</span><br><span class="line">            it.onNext(<span class="string">"items：1"</span>)</span><br><span class="line">            it.onNext(<span class="string">"items：2"</span>)</span><br><span class="line">            it.onError(Exception())</span><br><span class="line">            it.onComplete()</span><br><span class="line">        &#125;.subscribe(object : Observer&lt;String&gt; &#123;</span><br><span class="line">            <span class="function">override fun <span class="title">onSubscribe</span><span class="params">(d: Disposable)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"subscribe事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">override fun <span class="title">onNext</span><span class="params">(s: String)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Next事件：$s"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">override fun <span class="title">onError</span><span class="params">(e: Throwable)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Error事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">override fun <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Complete事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>那么现在我们就要对整个结构进行一个分析：</p>
<ol>
<li>Observable.create：对象是如何创建的？</li>
<li>Observer：观察者的函数调用过程是怎么样的</li>
<li>subsrcibe：是如何将<code>Observer</code>和<code>Observable</code>进行关联，如果是不同线程之间呢？</li>
</ol>
<h2 id="Observable-create"><a href="#Observable-create" class="headerlink" title="Observable.create"></a>Observable.create</h2><p><code>create</code>函数作为一个泛指的存在，他还可以是<code>just</code>、<code>fromArray</code>。。他们最后都会出现一个相同的函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RxJavaPlugins.onAssembly(...);</span><br><span class="line"><span class="comment">// 出现了这样的几个类</span></span><br><span class="line"><span class="comment">// 1. ObservableFromArray</span></span><br><span class="line"><span class="comment">// 2. ObservableJust</span></span><br><span class="line"><span class="comment">// 3. ObservableFromIterable</span></span><br><span class="line"><span class="comment">// 4. ....</span></span><br><span class="line"><span class="comment">// 他们全部继承了Observable，他们有这样一个相同的重写方法subscribeActual(Observer)</span></span><br></pre></td></tr></table></figure>
<p>我们主要拿<code>create</code>这个函数和这一整套流程来做一个详细的讲解。</p>
<h2 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h2><blockquote>
<p>为了让代码纹理更清晰，删掉了健壮代码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行链接</span></span><br><span class="line">            observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line">            <span class="comment">// 使得observable和observer进行了链接</span></span><br><span class="line">            subscribeActual(observer); <span class="comment">// 1 --&gt;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(e);</span><br><span class="line">            RxJavaPlugins.onError(e);</span><br><span class="line">            npe.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> npe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么我们就要看看这个<code>subscribeActual()</code>这个函数干了什么事情了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;&gt;(observer);</span><br><span class="line">        observer.onSubscribe(parent); <span class="comment">// 2 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            source.subscribe(parent); <span class="comment">// 3 --&gt;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>希望读者能够注意到这样的代码<code>CreateEmitter</code>消息发射器的创建，以及<code>onSubsrcibe()</code>的链接，以及<code>source.subscribe(parent);</code>数据的订阅。</p>
<p><code>onSubscribe()</code>说明我们的函数已经完成了订阅。</p>
<h3 id="CreateEmitter"><a href="#CreateEmitter" class="headerlink" title="CreateEmitter"></a>CreateEmitter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</span><br><span class="line"></span><br><span class="line">        CreateEmitter(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.observer = observer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一消息发送  </span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 错误发送</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!tryOnError(t)) &#123;</span><br><span class="line">                RxJavaPlugins.onError(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成连接</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 断开连接</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DisposableHelper.isDisposed(get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们清楚的看到了整个数据处理的逻辑，那么我们的<code>Observer</code>可以理解为我们一个用于自定义处理的类。</p>
<p>抛出一个问题，<strong>为什么我们的数据在经过一个报错之后往后的数据就不会再进行收发了？</strong></p>
<p>请注意看看<code>onError</code>的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryOnError(t)) &#123;</span><br><span class="line">        RxJavaPlugins.onError(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t = ExceptionHelper.createNullPointerException(<span class="string">"onError called with a null Throwable."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            observer.onError(t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 消息中出现错误后，断开连接</span></span><br><span class="line">            dispose();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在完成一次报错的操作之后，我们的连接就被关闭了，所以我们之后的数据也就无法进行了接收。</p>
<h2 id="source-subscribe-parent"><a href="#source-subscribe-parent" class="headerlink" title="source.subscribe(parent);"></a>source.subscribe(parent);</h2><p>上文中因为直接使用了<code>Kotlin</code>的<code>lambda</code>表达式，所以不够直观，这里我转成<code>Java</code>写一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;Object&gt; emitter)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>这是一个<code>Observable</code>的创建流程，显然我们现在看到的函数就是我们要找的被进行重写的函数了。内部使用到的<code>onNext()</code>、<code>onCompelete()</code>等函数的定义就是由我们的<code>ObservableEmitter</code>来直接完成提供的。</p>
<h2 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h2><p><img src= "/img/loading.gif" data-src="https://upload-images.jianshu.io/upload_images/2427349-38e92bfa5823d0c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1133" alt=""></p>
<h3 id="RxJava的异步通信原理"><a href="#RxJava的异步通信原理" class="headerlink" title="RxJava的异步通信原理"></a>RxJava的异步通信原理</h3><h4 id="observeOn-的线程切换原理"><a href="#observeOn-的线程切换原理" class="headerlink" title="observeOn() 的线程切换原理"></a>observeOn() 的线程切换原理</h4><p>对于<code>observeOn()</code>而言，进入源码中我们能知道，它使用了这样的一个类<code>ObservableObserveOn</code>，而我们传入的值就是我上文所提到过的<code>Schedulers</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObservableObserveOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(source);</span><br><span class="line">    <span class="keyword">this</span>.scheduler = scheduler; <span class="comment">// 我们传入的Scheduler</span></span><br><span class="line">    <span class="keyword">this</span>.delayError = delayError; <span class="comment">// 延迟onError输出</span></span><br><span class="line">    <span class="keyword">this</span>.bufferSize = bufferSize; <span class="comment">// 缓冲区大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们再这个类的他的<code>subscribeActual()</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">            source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>显然对<code>Scheduler</code>进行了使用，那么我们从前面的文章能够作出一个推测，这个数据的响应者就应该是<code>ObserveOnObserver</code>这个类了。</p>
<p>那我们再进入一层，看看他的构成，能看到如下的代码<code>(onComplete()、onSubscribe()..)</code>皆可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">                queue.offer(t); <span class="comment">// 1--&gt;</span></span><br><span class="line">            &#125;</span><br><span class="line">            schedule(); <span class="comment">// 2--&gt;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>他的<code>onNext()</code>的函数中存在一个异步判断，而数据就是从一个队列中取出来的。这个队列先暂时放一边，我们猜测他和我们之前的缓存区相关。</p>
<p>先看看注释2的<code>schedule()</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">        worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他会调用到这个函数一个<code>worker</code>,而这个<code>worker</code>就是我们传入的<code>Scheduler</code>所拥有的函数了，我们选择用<code>newThread()</code>来进行一个查看，而<code>this</code>就是<code>ObserveOnObserver</code>本身了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker.createWorker()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NewThreadWorker(threadFactory); <span class="comment">// 1 --&gt; </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 1--&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NewThreadWorker</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建了一个线程池</span></span><br><span class="line">        executor = SchedulerPoolFactory.create(threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// worker.schedule(this);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull <span class="keyword">final</span> Runnable action, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (disposed) &#123;</span><br><span class="line">            <span class="keyword">return</span> EmptyDisposable.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scheduleActual(action, delayTime, unit, <span class="keyword">null</span>); <span class="comment">// 2 --&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 2 --&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ScheduledRunnable <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent)</span> </span>&#123;</span><br><span class="line">        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">        ScheduledRunnable sr = <span class="keyword">new</span> ScheduledRunnable(decoratedRun, parent);</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">        Future&lt;?&gt; f;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用一个线程池来维持数据的数据的有效运行</span></span><br><span class="line">            <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            sr.setFuture(f); <span class="comment">// 通过返回新的线程并设置完成线程切换</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.remove(sr);</span><br><span class="line">            &#125;</span><br><span class="line">            RxJavaPlugins.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>将我们的<code>ObserveOnObserver</code>扔进了线程池以后就已经完成了线程切换了。</p>
<h4 id="subscribeOn-的线程切换原理"><a href="#subscribeOn-的线程切换原理" class="headerlink" title="subscribeOn() 的线程切换原理"></a>subscribeOn() 的线程切换原理</h4><p><strong>抛出一个问题，为什么网上都说<code>subscribeOn()</code>只会生效一次？</strong></p>
<p>我们再次慢慢地用源码说明问题，下方是<code>ObservableSubscribeOn</code>类的<code>subscribeActual()</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建了与之绑定用的SubscribeOnObserver</span></span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;&gt;(observer);</span><br><span class="line"></span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line">        <span class="comment">// SubscribeTask就是一个Runnable</span></span><br><span class="line">        <span class="comment">// 然后scheduler不知干了什么事情</span></span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent))); <span class="comment">// 1--&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(@NonNull Runnable run, <span class="keyword">long</span> delay, @NonNull TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Worker w = createWorker();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line">        <span class="comment">// 只是将Runnable 和 Worker进行绑定</span></span><br><span class="line">        DisposeTask task = <span class="keyword">new</span> DisposeTask(decoratedRun, w); </span><br><span class="line">        <span class="comment">// schedule的函数是否有所眼熟</span></span><br><span class="line">        <span class="comment">// 在上文的observeOn中我们也有所提及</span></span><br><span class="line">        <span class="comment">// 使用了线程池来进行维护的线程切换的位置</span></span><br><span class="line">        w.schedule(task, delay, unit); <span class="comment">// 2--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>经过上述步骤后我们就获取了对应的<code>Disposable</code>，那就进入了<code>parent.setDisposable()</code>的函数了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDisposable</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            DisposableHelper.setOnce(<span class="keyword">this</span>, d);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>其实从名字我们就看出来一个问题了<code>setOnce()</code>，已经说明只能值设置一次，所以已经这里已经证明了为什么我的<code>subscribeOn()</code>只有第一次设置的时候才会生效的原因了。</p>
<p><strong>收！</strong> 回到我们的线程内容，既然是线程池，自然要看看他对应的线程了，看看我们的<code>DisposeTask</code>的<code>run()</code>函数把。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runner = Thread.currentThread(); </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                decoratedRun.run(); <span class="comment">// 1 --&gt; SubscribeTask</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                runner = <span class="keyword">null</span>; <span class="comment">// 当前线程运行完就释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应我们SubscribeTask中的run()函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这个source就是我们的observable</span></span><br><span class="line">            source.subscribe(parent); </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>上流事件也就是让上层的<code>Observable</code>又对我们的数据<code>SubscribeOnObserver</code>进行了一次订阅，这个时候线程又一次进行了切换操作。</p>
<h3 id="RxAndroid是如何完成异步的通信的？"><a href="#RxAndroid是如何完成异步的通信的？" class="headerlink" title="RxAndroid是如何完成异步的通信的？"></a>RxAndroid是如何完成异步的通信的？</h3><p>对我们的一个RxAndroid而言，一般谁是在IO线程，谁在UI线程呢？</p>
<p>好吧，直接问，可能会没有思路，那我们换个问题，<strong>谁是数据产生者，谁是数据消费者？</strong> 对应到我们的网络请求过程，显然网络请求是一个在子线程工作的任务，而数据更新就是在主线程。那么对应到我们的<code>RxJava</code>，显然是<code>Observable</code>是产生者，而<code>Observer</code>是消费者，那么我们也就知道了谁应该在IO线程了，显然是<code>Observable</code>，而<code>Observer</code>应该处于UI线程了。但是这就是问题所在了，我们该如何进行数据的通信呢？我的被观察者有数据了，但是我们的观察者该如何知道？</p>
<p>先来看一下如何进行使用，我们应该在IO线程中进行订阅，在UI线程中进行观察。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.subscribeOn(Schedulers.io()) <span class="comment">// 对应 被观察者</span></span><br><span class="line">.observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 对应 观察者</span></span><br></pre></td></tr></table></figure>

<p>在上文中我们提到了一个叫做缓存区的概念，在我们的<code>FlowableCreate</code>的源码中能找到关于这一部分的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在源码的64行上下</span></span><br><span class="line">emitter = <span class="keyword">new</span> BufferAsyncEmitter&lt;&gt;(t, bufferSize());</span><br><span class="line"><span class="comment">// bufferSize()函数对应的数据就是我们的128</span></span><br><span class="line"><span class="comment">// 所以会有我们缓存超出128时报错的情况存在</span></span><br></pre></td></tr></table></figure>
<p>但是这里我们并没有看到和数据发送相关的内容，只看到一个缓冲区的存在。那我们就继续往下进行分析了。我们之前分析过<code>Observer</code>的源码，里面使一些接收的过程，而<code>Subscribe</code>也差不多，所以方案也同样的不在这个类中。</p>
<p>那就进行定位了，是我们最开始的代码起了什么样的作用。</p>
<h3 id="AndroidSchedulers-mainThread"><a href="#AndroidSchedulers-mainThread" class="headerlink" title="AndroidSchedulers.mainThread()"></a>AndroidSchedulers.mainThread()</h3><p>对于Emitter而言，其实他已经持有了订阅的对象，可以直接发送数据，有点类似于观察者模式，但是<code>Flowable</code>中我们能够发现的数据拉取，其实是通过<code>FlowableSubscriber</code>来进行主动拉取，和观察者模式的主动推送有一定的区别。</p>
<p>但是数据的通信还是需要看看我们的<code>AndroidSchedulers.mainThread()</code>。因为我们要进行UI线程的数据更新，自然是不会使用上述的方法进行的，那RxJava是如何完成这样的操作的呢。</p>
<p>进入到<code>observeOn</code>的源码中能看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        Worker worker = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> ConditionalSubscriber) &#123;</span><br><span class="line">            source.subscribe(<span class="keyword">new</span> ObserveOnConditionalSubscriber&lt;&gt;(</span><br><span class="line">                    (ConditionalSubscriber&lt;? <span class="keyword">super</span> T&gt;) s, worker, delayError, prefetch));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            source.subscribe(<span class="keyword">new</span> ObserveOnSubscriber&lt;&gt;(s, worker, delayError, prefetch));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们能够看到这样的一段代码<code>scheduler.createWorker()</code>，我们拿<code>AndroidSchedulers.mainThread()</code>来看上一看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidSchedulers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT</span><br><span class="line">            = <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(Looper.getMainLooper()), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HandlerScheduler(Handler handler, <span class="keyword">boolean</span> async) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.async = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在类<code>AndroidSchedulers</code>中的构造能够发现其实最后使用的就是一个<code>Handler</code>的机制，也就是说最后要切到主线程时使用的就是<code>Handler</code>的机制来发送消息了，而且他直接获取了主线程的Looper，将消息直接传输到了主线程。</p>
<p>那么讲述到这儿我们的<code>RxJava</code>的整体流程就已经讲完了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/5/9/171f7dd39c27df94?w=1192&h=784&f=png&s=281813" alt=""></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>Carson_Ho大佬的RxJava的系列文章：<a href="https://www.jianshu.com/p/e1c48a00951a" target="_blank" rel="noopener">https://www.jianshu.com/p/e1c48a00951a</a></li>
<li>详解 RxJava2 的线程切换原理：<a href="https://www.jianshu.com/p/a9ebf730cd08" target="_blank" rel="noopener">https://www.jianshu.com/p/a9ebf730cd08</a></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cleric Yi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/06/24/%E9%94%A6%E5%9B%8A%E7%AF%87%EF%BD%9C%E4%B8%80%E6%96%87%E6%91%B8%E6%87%82RxJava/">http://yoursite.com/2020/06/24/%E9%94%A6%E5%9B%8A%E7%AF%87%EF%BD%9C%E4%B8%80%E6%96%87%E6%91%B8%E6%87%82RxJava/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">ClericYi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/24/%E5%85%B3%E4%BA%8EJVM%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E7%8E%A9%E6%84%8F%E5%84%BF/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关于JVM，你必须知道的那些玩意儿</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/24/%E9%94%A6%E5%9B%8A%E7%AF%87%EF%BD%9C%E4%B8%80%E6%96%87%E6%91%B8%E6%87%82EventBus/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">锦囊篇｜一文摸懂EventBus</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Cleric Yi</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script></body></html>